'use server';
/**
 * @fileOverview A flow for sending WhatsApp messages generated by an AI.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit';
import { type Client } from 'whatsapp-web.js';
import { doc, updateDoc, increment, setDoc, addDoc, collection, serverTimestamp } from 'firebase/firestore';
import { db } from '@/lib/firebase';

const ContactSchema = z.object({
    id: z.string(),
    name: z.string(),
    phone: z.string().optional(),
    product: z.string(),
    userId: z.string(),
});
export type Contact = z.infer<typeof ContactSchema>;

// Define the prompt for generating the recovery message
const generateRecoveryMessagePrompt = ai.definePrompt({
  name: 'generateRecoveryMessage',
  input: {
    schema: z.object({
      name: z.string(),
      product: z.string(),
    }),
  },
  output: {
    schema: z.object({
        message: z.string().describe("The generated recovery message to be sent to the user.")
    })
  },
  prompt: `Você é um especialista em vendas carismático e amigável. Sua tarefa é escrever uma mensagem curta e persuasiva para um cliente que abandonou um carrinho de compras.

O tom deve ser prestativo e nunca agressivo. O objetivo é reengajar o cliente e lembrá-lo do produto que ele estava prestes a comprar.

Use o nome do cliente e o nome do produto fornecidos para personalizar a mensagem.

Cliente: {{{name}}}
Produto: {{{product}}}

Gere apenas o texto da mensagem a ser enviada.`,
});

/**
 * Splits the AI-generated message into individual phrases and sends them one by one
 * with a random delay to simulate human typing.
 * @param client The WhatsApp client instance.
 * @param chatId The chat ID to send the message to.
 * @param fullMessage The complete message generated by the AI.
 */
async function separarEEnviarFrases(client: Client, chatId: string, fullMessage: string): Promise<void> {
    // Split the message by periods, exclamation marks, or commas.
    const frases = fullMessage.split(/([.,!])\s*/).filter(Boolean);

    // This regex helps group sentences with their punctuation.
    const sentencasAgrupadas = [];
    for (let i = 0; i < frases.length; i += 2) {
        let sentenca = frases[i];
        if (frases[i + 1]) {
            sentenca += frases[i + 1];
        }
        sentencasAgrupadas.push(sentenca.trim());
    }

    for (const sentenca of sentencasAgrupadas) {
        if (sentenca) {
            console.log(`Sending phrase to ${chatId}: "${sentenca}"`);
            await client.sendMessage(chatId, sentenca);
            // Wait for a random time between 1 to 3 seconds to simulate typing
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}


export async function sendMessage(contacts: Contact[], client: Client): Promise<void> {
    console.log(`Received ${contacts.length} contacts to message.`);
    
    for (const contact of contacts) {
      if (contact.phone) {
        // Format phone number for whatsapp-web.js (e.g., 5511999999999@c.us)
        const sanitizedPhone = contact.phone.replace(/[^0-9]/g, '');
        const chatId = `${sanitizedPhone}@c.us`;
        
        try {
          // Generate the message using the AI prompt
          console.log(`Generating message for ${contact.name} and product ${contact.product}...`);
          const { output } = await generateRecoveryMessagePrompt({
            name: contact.name,
            product: contact.product,
          });

          if (!output?.message) {
            console.error(`AI failed to generate a message for contact ${contact.id}.`);
            continue; 
          }
          const message = output.message;
          
          // Send the message phrase by phrase
          await separarEEnviarFrases(client, chatId, message);
          
          // Update contact status to 'Contatado' in Firestore
          const contactRef = doc(db, 'contacts', contact.id);
          await updateDoc(contactRef, {
            status: 'Contatado'
          });
            
          // Log the sent message for stats
          await addDoc(collection(db, 'message_logs'), {
            userId: contact.userId,
            contactId: contact.id,
            timestamp: serverTimestamp(),
          });

          // Increment total message counter (optional, can be removed if only time-based stats are needed)
          const userStatsRef = doc(db, 'user_stats', contact.userId);
          await setDoc(userStatsRef, { 
            messagesSent: increment(1),
          }, { merge: true });
          
          console.log(`Successfully sent message and updated status for contact ${contact.id}`);
        } catch (error) {
          console.error(`Failed to send message or update status for contact ${contact.id} (${contact.name}) at ${chatId}:`, error);
        }
      } else {
        console.log(`Skipping contact ${contact.name} (ID: ${contact.id}) due to missing phone number.`);
      }
    }
}
